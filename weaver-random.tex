\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Gerador de Números Aleatórios Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article is an informal survey and analysis of random
number generators in games. It also contains a random number generator
described using literary programming.}

\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo é uma pesquisa informal sobre geradores de números
aleatórios em jogos. Ela também contém um gerador de números aleatórios
decrito usando programação literária.}

\secao{1. Introdução}

\subsecao{1.1. Geradores de Números Aleatórios em Jogos Eletrônicos}

Um gerador de números aleatórios é útil para os seguintes cenários em
um jogo eletrônico:

a) Simular Fenômenos: Isso se aplica tanto a fenômenos naturais que
podem ser aleatórios como a fenômonos sociais, por exemplo. Isso é
usado exaustivamente em jogos que são simuladores, como simuladores de
cidades como SimCity. Mas pode ser usado para simular variações no
clima ou direção do vento em quase qualquer tipo de jogo.

b) Amostragem: Podem existir muitos tipos diferentes de oponentes que
podem ser gerados. Gerando as características variáveis aleatoriaente
estamos simulando a amostragem de um deles dentre os vários outros
possíveis. Por exemplo, em um jogo de Pokémon, determinada espécie de
criatura pode possuir muitas variações diferentes como atributos que
dependem de sua genética ou em que tipos de golpes ela pode
realizar. Ao gerar uma criatura aleatória, obtemos uma amostragem de
uma dentre várias outras. Há o caso de simulações de mundos inteiros
gerados de maneira procedural.

c) Programação: Durante o desenvolvimento de certos tipos de jogos,
pode-se qurer testar seu funcionamento fazendo-o rodar substituindo as
opções do jogador por alguma IA que realiza suas escolhas de maneira
não-probabilística. Ou então, para se gerar níveis aleatórios de um
jogo para fins de experimentos.

d) Tomada de decisão: Em um RPG, por exemplo, um personagem poderia
conversar com algum tipo de personagem conselheiro, que diante de uma
questão, poderia responder aleatoriamente para o jogador qual ele acha
que é a melhor ação a ser tomada.

e) Estética: Adicionar aleatoriamente pequenas aleatoriedades em
padrões de imagens que de outra forma seriam regulares pode aumentar o
apelo estético de uma imagem. A aleatoriedade pode tornar também
efeitos de transição de telas mais interessantes.

f) Recreação: Um jogo eletrônico em princípio é inteiramente sobre
recreação. Mas é possível simular dentro deles jogos recreativos mais
clássicos que dependem da sorte como dados, roletas, baralhos.

Esta lista foi adaptada da apresentada em [Knuth 1998]. Todos os
exemplos apresentados nela foram adaptados acima para o cenário de
jogos eletrônicos, exceto um (análise numérica).

Como há tantos casos de uso diferentes para geradores de números
aleatórios em jogos eletrônicos, o gerador ideal usado neles deve ser
um projetado para casos bastante gerais. Um motor para criação de
jogos eletrônicos não deve fornecer um gerador otimizado para uma das
tarefas, mas que seja ruim nas demais.

Apesar disso, geralmente há uma tolerância maior para quando um
gerador de números aleatórios gera resultados não tão aleatórios em um
jogo eletrônico. As consequências são muito menos desagradáveis do que
quando isso ocorre em aplicações criptográficas, por exemplo. Muitos
jogos antigos usavam geradores que consistiam apenas em uma sequência
de números fixos. E o viés de seus geradores não era necessariamente
aparente. Por outro lado, há ocasiões nas quais um gerador ruim pode
ter consequências desagradáveis. Em simuladores que almejam realismo,
em jogos envolvendo apostas ou competições sérias, ou naqueles em que
certas ocorrências aleatórias devam ser raras e o desenvolvedor não
deseja que o gerador seja manipulado para aumentar as chances de um
jogador. Levando isso em conta, o padrão de um gerador de números
aleatórios de um jogo deve ser alto e deve-se esperar que ele passe em
testes estatísticos.

\subsecao{1.2. Programação Literária e Notação Usada no Artigo}

Este artigo utiliza a técnica de ``Programação Literária'' para
desenvolver o seu gerador de números aleatórios. Esta técnica foi apresentada
em [Knuth, 1984] e consiste e uma filosofia de desenvolvimento de
\italico{software} na qual um programador desenvolve um programa escrevendo
e explicando didaticamente o código necessário, se preocupando em
deixar o seu funcionamento claro para as pessoas que lerem a
explicação. Ferramentas automáticas são então utilizadas para extrair
o código existente na expicação, mudar a ordem do código conforme for
mais adequado para o compilador e produzir à partir do código extraído
um programa executável.

Por exemplo, neste artigo serão definidos dois arquivos
diferentes: \monoespaco{random.c} e \monoespaco{random.h}, os quais
podem ser inseridos estaticamente em qualquer projeto, ou compilados
como uma biblioteca compartilhada. O conteúdo de \monoespaco{random.h}
é:

\iniciocodigo
@(src/random.h@>=
#ifndef WEAVER_RANDOM
#define WEAVER_RANDOM
#ifdef __cplusplus
extern "C" {
#endif
#include <stdint.h>
@<Estrutura RNG@>
@<Declarações de Gerador Aleatório@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

As duas primeiras linhas assim como a última são macros de segurança
que impedem que as funções e variáveis declaradas ali sejam declaradas
redundantemente se alguém incluir mais de uma vez o arquivo em um
código-fonte. As demais linhas contém macros que checam se estamos
compilando usando C++ ao invés de C. Se for o caso, nós declaramos
todas as funções que existem neste arquivo como funções do tipo C,
para que o compilador C++ saiba que elas não serão modificadas por
meio de sobrecarga de operadores e que por isso não é necessário
armazenar informações adicionais além do nome da função para
reconhecê-la.

No meio do código acima, deixamos indicado em letras vermelhas que
iremos adicionais mais tarde ali um novo trecho de código chamado
``Declarações de Gerador Aleatório'', com a declaração das funções que
iremos usar. Folheando o artigo, você encontrará nas páginas seguintes
um outro trecho de código cujo título não será \monoespaco{random.h},
mas sim ``Declarações de Gerador Aleatório''. Será ali que o código que
vai nesta parte do arquivo será encontrado. Pdem existir mais de um
trecho de código com este título. Isso significa que para produzir o
código funcional utilizado pelo compilador, devemos concatenar todos
estes trechos com o mesmo título e colocar na parte indicada deste
arquivo. Isso nos permite colocar a declaração de funções à medida que
formos explicando elas no código, sem precisar declarar todas de uma
vez só porque elas pertencem a um mesmo trecho de código.

\subsecao{1.4. Funções a serem Definidas}

Nosso gerador de números aleatórios deverá fornecer um total de 3
novas funções. A primeira delas irá criar a estrutura que contém o
gerador após receber a semente inicial e deve receber a função que
alocará o alocador (ou \monoespaco{NULL} para usar
o \monoespaco{malloc}):

\iniciocodigo
@<Declarações de Gerador Aleatório@>=
struct _Wrng *_Wcreate_rng(void *(*alloc)(size_t), void *seed);
@
\fimcodigo

A segunda é a que efetivamente é usada para nos dar o próximo número
aleatório da sequência:

\iniciocodigo
@<Declarações de Gerador Aleatório@>+=
uint64_t _Wrand(struct _wrng *);
@
\fimcodigo

A terceira função serve para inserir bytes de entropia no gerador:

\iniciocodigo
@<Declarações de Gerador Aleatório@>+=
void _Wrng_entropy(struct _wrng *rng, size_t size, char *entropy);
@
\fimcodigo

\secao{2. Algoritmos Geradores de Números Pseudo-Randômicos}

\subsecao{2.1. SFMT}

O SFMT é o ``SIMD-Oriented Fast Mersenne Twister''. Ele tem esse nome
porque o período deste gerador é projetado para ter valores bastante
grandes, que são primos de Mersenne ($2^n-1$ para algum $n$ inteiro
positivo). As implementações mais usadas deste algoritmo suportam
períodos de $2^{19937}-1$ sem que haja repetição. O que é um exagero
para qualquer caso de uso, inclusive o uso em jogos eletrônicos. Já o
``SIMD'' é um conjunto de instruções para valores de 128 bits que CPUs
mais recentes suportam. Tais instruções, se suportadas, são usadas
para tornar o desempenho mais rápido.

Como geradores de números randômicos são na prática tão rápidos, algo
que mpacta muito na velocidade de sua geração é a necessidade de
invocar funções. Há duas formas de mitigar isso: gerar uma grande
quantidade de números em um buffer, que deve ser preenchido novamente
quando eles acabarem, ou pedir para o compilador tornar a
função \italico{inline\/}. Geralmente a primeira opção é
preferida. Contudo, o momento de preencher o buffer de números será
quando a função acabará tendo uma queda de desempenho inesperada. Em
programas interativos, geralmente é melhor que as funções tenham um
comportamento mais fixo. É melhor garantir uma taxa de atualização de
tela constante do que garantir uma taxa de atualização mais rápida, só
que com quedas de desempenho ocasionais. Sendo assim, iremos preferir
usar a função do modo \italico{inline\/}. Isso não é um grande
problema devido aos algoritmos de geração de números pseudo-randômico
na prática serem bastante simples.

O SFMT funciona por meio da seguinte recursão onde cada valor $X_i$ tem
$w$ bits:

$$
X_{i+n}=g(X_i, \ldots, X_{i+n-1})
$$

A função $g$ funciona concatenando toda a sua entrada na forma de um
vetor binário em $\mathbb{F}_2$ com $wn$ elementos e multiplicando por
uma matriz $A\in\mathbb{F}_2^{wn\times w}$. Na prática essa matriz é
escolhida de modo a ser simples e assim não precisar ser representada
ou armazenada. Ao invés disso ela simplesmente existirá na forma de
rotações de bits, operações AND e operações de XOR (os quais
correspondem à multiplicação e adição no corpo $\mathbb{F}$_2).

Essa descrição genérica descreve toda a família de geradores Mersenne
Twister. Para o caso específico do SFMT, os valores que escolheremos
para nossas constantes será:

\iniciocodigo
@<Constantes RNG@>=
#ifdef W_MERSENNE_TWISTER
#define W = 128; // Tamanho de cada X_i gerado
#define N = 156; // Tamanho da recursão
#endif
@
\fimcodigo

Cada vez que geramos um novo número, temos que fazer a atualização
$w_0 \leftarrow w_1$, $w_1 \leftarrow w_2$ e assim por diante. Mas
podemos evitar ter que fazer tantas atribuições ou cópia mantendo
apenas uma variável com o índice de qual deverá ser o próximo elemento
a ser modificado de nossa sequência fixa de \monoespaco{N}
valores. Além disso, como queremos uma função que retorne 64 bits, mas
nosso gerador funciona com valores de 128 bits, então precisaremos de
uma variável booleana para dizer se devemos retornar o restante de um
valor já gerado ou se devemos gerar um novo valor e retornar seus
primeiros 64 bits. Sendo assim, o formato de nossa estrutura de RNG
será:

\iniciocodigo
@<Estrutura RNG@>=
#ifdef W_MERSENNE_TWISTER
struct _Wrng{
  char w[W * N / 8]; // Todos N valores gerados, cada um com W bits
  int index;         // Onde colocar próximo valor: (index * W / 8)
  bool require_new;  // Se temos que gerar novo valor
};
#endif
@
\fimcodigo

O padrão ISO da linguagem C não suporta variáveis que garantidamente
tenham 128 bits. Contudo, versões recentes do compilador GCC e Clang
as suportam. Usando elas, podemos computar a função $g$ que computa o
próximo elemento da sequência (ou seja, a multiplicação de nosso vetor
por uma matriz em $\mathbb{F}_2$) por meio da seguintes operações:

\iniciocodigo
@<SFMT: Computa próximo elemento@>=
#ifdef __SIZEOF_INT128__
unsigned __int128 result;
uint32_t aux[4];
int i;
result = ((unsigned __int128 *) (rng -> w))[index];
result = result << 8;
result = result ^ ((unsigned __int128 *) (rng -> w))[index];
i = (rng -> index + 122) % N;
aux[0] = (uint32_t) ((unsigned __int128 *) (rng -> w))[i];
aux[1] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 1);
aux[2] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 2);
aux[3] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 3);
i = (rng -> index + N - 2) % N;
result = result ^ (((unsigned __int128 *) (rng -> w))[i] >> 8);
aux[0] = (aux[0] >> 11) & 0xBFFFFFF6;
aux[1] = (aux[1] >> 11) & 0xBFFAFFFF;
aux[2] = (aux[2] >> 11) & 0xDDFECB7F;
aux[3] = (aux[3] >> 11) & 0xDFFFFFEF;
result = result ^ (unsigned __int128) aux;
i = (rng -> index + N - 1) % N;
aux[0] = (uint32_t) ((unsigned __int128 *) (rng -> w))[i];
aux[1] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 1);
aux[2] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 2);
aux[3] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 3);
aux[0] = (aux[0] << 18);
aux[1] = (aux[1] << 18);
aux[2] = (aux[2] << 18);
aux[3] = (aux[3] << 18);
result = result ^ (unsigned __int128) aux;
rng -> index = (rng -> index + 1) % N;
rng -> require_new = false;
((unsigned __int128 *) (rng -> w))[index] = result;
return (uint64_t) (result >> 64);
#else
#error "Mersenne Twister unsupported without 128 bit integer support." 
#endif
@
\fimcodigo

Essa geração de um próximo valor pseudo-randômico $w_i$ à partir de
$w_{i-1}$, $w_{i-2}$, $w_{i-N}$ e $w_{i-34}$ precisa ser então
integrada à função que efetivamente retorna o próimo número:

\iniciocodigo
@<Definição de \_Wrand@>=
#ifdef W_MERSENNE_TWISTER
uint64_t _Wrand(struct _wrng *rng){
  if(rng -> require_new){
    @<SFMT: Computa próximo elemento@>
  }
  else{
    unsigned __int128 result;
    rng -> require_new = true;
    result = ((unsigned __int128 *) (rng -> w))[index];
    rng -> index = (rng -> index + 1) % N;
    return (result << 64) >> 64;
  }
}
#endif
@
\fimcodigo

Inicializar o nosso gerador é então uma questão de alocar espaço,
copiar os bytes aleatórios iniciais para a nossa sequência de $w$
números aleatórios de 128 bits e ajustar as variáveis:

\iniciocodigo
@<Definição de \_Wcreate\_rng@>=
#ifdef W_MERSENNE_TWISTER
struct _Wrng *_Wcreate_rng(void *(*alloc)(size_t), void *seed);
  struct _Wrng *new = (struct _Wrng *) alloc(sizeof(struct _Wrng));
  if(new != NULL){
    memcpy(rng -> w, seed, W * N / 8);
    rng -> index = 0;
    rng -> require_new = true;
  }
  return new;
}
#endif
@
\fimcodigo

Mas como saber qual é o tamanho no buffer correto onde a semente
inicial deve ser colocada? Isso será declarado no cabeçalho:

\iniciocodigo
@<Declarações de Gerador Aleatório@>+=
#ifdef W_MERSENNE_TWISTER
#define W_SEED_SIZE (128 * 156 / 8)
#endif
@
\fimcodigo

Por fim, para adicionar mais aleatoriedade ao nosso gerador depois de
usarmos ele por algum tempo, basta adicionar tal aleatoriedade
diretamente no buffer de valores $w$:

\iniciocodigo
@<Definição de \_Wrng\_entropy@>=
#ifdef W_MERSENNE_TWISTER
void _Wrng_entropy(struct _wrng *rng, size_t size, char *entropy){
  size_t real_size = (size > W_SEED_SIZE):(W_SEED_SIZE):(size);
  memcpy(rng -> w, entropy, real_size);
}
#endif
@
\fimcodigo

\subsecao{2.X. Estrutura Final do Arquivo}

O arquivo com o código-fonte de nossas funções terá a seguinte forma:


\iniciocodigo
@(src/random.c@>=
@<Incluir Cabeçalhos Necessários@>
#include "random.h"
@<Constantes RNG@>
@<Definição de \_Wrand@>
@<Definição de \_Wcreate\_rng@>
@<Definição de \_Wrng\_entropy@>
@
\fimcodigo


\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer Journal,
volume 27, edição 2, p. 97--111}

\referencia{Knuth, D. (1998) ``The Art of Computer Programming, v. 2:
Seminumerical Algorithms'', Addison-Wesley Professional, terceira
edição.}

\referencia{Astrizi, T. L. (2019), ``Gerenciador de Memória Weaver'',
visualizado em 14 de agosto de 2020:
\monoespaco{https://github.com/thiagoharry/weaver-memory-manager}}

\fim
