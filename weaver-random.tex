\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Gerador de Números Aleatórios Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article is an informal survey and analysis of random
number generators in games. It also contains a random number generator
described using literary programming, which is part of Weaver Game Engine.}

\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo é uma pesquisa informal sobre geradores de números
aleatórios em jogos. Ela também contém um gerador de números aleatórios
decrito usando programação literária, o qual faz parte do motor de jogos Weaver.}

\secao{1. Introdução}

\subsecao{1.1. Geradores de Números Aleatórios em Jogos Eletrônicos}

Um gerador de números aleatórios é útil para os seguintes cenários em
um jogo eletrônico:

a) Simular Fenômenos: Isso se aplica tanto a fenômenos naturais que
podem ser aleatórios como a fenômonos sociais, por exemplo. Isso é
usado exaustivamente em jogos que são simuladores, como simuladores de
cidades como SimCity. Mas pode ser usado para simular variações no
clima ou direção do vento em quase qualquer tipo de jogo.

b) Amostragem: Podem existir muitos tipos diferentes de oponentes que
podem ser gerados. Gerando as características variáveis aleatoriaente
estamos simulando a amostragem de um deles dentre os vários outros
possíveis. Por exemplo, em um jogo de Pokémon, determinada espécie de
criatura pode possuir muitas variações diferentes como atributos que
dependem de sua genética ou em que tipos de golpes ela pode
realizar. Ao gerar uma criatura aleatória, obtemos uma amostragem de
uma dentre várias outras. Há o caso de simulações de mundos inteiros
gerados de maneira procedural.

c) Programação: Durante o desenvolvimento de certos tipos de jogos,
pode-se qurer testar seu funcionamento fazendo-o rodar substituindo as
opções do jogador por alguma IA que realiza suas escolhas de maneira
não-probabilística. Ou então, para se gerar níveis aleatórios de um
jogo para fins de experimentos.

d) Tomada de decisão: Em um RPG, por exemplo, um personagem poderia
conversar com algum tipo de personagem conselheiro, que diante de uma
questão, poderia responder aleatoriamente para o jogador qual ele acha
que é a melhor ação a ser tomada.

e) Estética: Adicionar aleatoriamente pequenas aleatoriedades em
padrões de imagens que de outra forma seriam regulares pode aumentar o
apelo estético de uma imagem. A aleatoriedade pode tornar também
efeitos de transição de telas mais interessantes.

f) Recreação: Um jogo eletrônico em princípio é inteiramente sobre
recreação. Mas é possível simular dentro deles jogos recreativos mais
clássicos que dependem da sorte como dados, roletas, baralhos.

Esta lista foi adaptada da apresentada em [Knuth 1998]. Todos os
exemplos apresentados nela foram adaptados acima para o cenário de
jogos eletrônicos, exceto um (análise numérica).

Como há tantos casos de uso diferentes para geradores de números
aleatórios em jogos eletrônicos, o gerador ideal usado neles deve ser
um projetado para casos bastante gerais. Um motor para criação de
jogos eletrônicos não deve fornecer um gerador otimizado para uma das
tarefas, mas que seja ruim nas demais.

Apesar disso, geralmente há uma tolerância maior para quando um
gerador de números aleatórios gera resultados não tão aleatórios em um
jogo eletrônico. As consequências são muito menos desagradáveis do que
quando isso ocorre em aplicações criptográficas, por exemplo. Muitos
jogos antigos usavam geradores que consistiam apenas em uma sequência
de números fixos. E o viés de seus geradores não era necessariamente
aparente. Por outro lado, há ocasiões nas quais um gerador ruim pode
ter consequências desagradáveis. Em simuladores que almejam realismo,
em jogos envolvendo apostas ou competições sérias, ou naqueles em que
certas ocorrências aleatórias devam ser raras e o desenvolvedor não
deseja que o gerador seja manipulado para aumentar as chances de um
jogador. Levando isso em conta, o padrão de um gerador de números
aleatórios de um jogo deve ser alto e deve-se esperar que ele passe em
testes estatísticos.

\subsecao{1.2. Programação Literária e Notação Usada no Artigo}

Este artigo utiliza a técnica de ``Programação Literária'' para
desenvolver o seu gerador de números aleatórios. Esta técnica foi apresentada
em [Knuth, 1984] e consiste e uma filosofia de desenvolvimento de
\italico{software} na qual um programador desenvolve um programa escrevendo
e explicando didaticamente o código necessário, se preocupando em
deixar o seu funcionamento claro para as pessoas que lerem a
explicação. Ferramentas automáticas são então utilizadas para extrair
o código existente na expicação, mudar a ordem do código conforme for
mais adequado para o compilador e produzir à partir do código extraído
um programa executável.

Por exemplo, neste artigo serão definidos dois arquivos
diferentes: \monoespaco{random.c} e \monoespaco{random.h}, os quais
podem ser inseridos estaticamente em qualquer projeto, ou compilados
como uma biblioteca compartilhada. O conteúdo de \monoespaco{random.h}
é:

\iniciocodigo
@(src/random.h@>=
#ifndef WEAVER_RANDOM
#define WEAVER_RANDOM
#ifdef __cplusplus
extern "C" {
#endif
#include <stdint.h>
#include <stdbool.h>
#if defined(__unix__) || defined(__APPLE__)
#include <pthread.h>
#endif
#if defined(W_RNG_ISO_C) || defined(W_RNG_CRYPTO)
#include <stdlib.h>
#endif
@<Escolhe Algoritmo Padrão do RNG@>
@<Constantes RNG@>
@<Estrutura RNG@>
@<Declarações de Gerador Aleatório@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

As duas primeiras linhas assim como a última são macros de segurança
que impedem que as funções e variáveis declaradas ali sejam declaradas
redundantemente se alguém incluir mais de uma vez o arquivo em um
código-fonte. As demais linhas contém macros que checam se estamos
compilando usando C++ ao invés de C. Se for o caso, nós declaramos
todas as funções que existem neste arquivo como funções do tipo C,
para que o compilador C++ saiba que elas não serão modificadas por
meio de sobrecarga de operadores e que por isso não é necessário
armazenar informações adicionais além do nome da função para
reconhecê-la.

No meio do código acima, deixamos indicado em letras vermelhas que
iremos adicionais mais tarde ali um novo trecho de código chamado
``Declarações de Gerador Aleatório'', com a declaração das funções que
iremos usar. Folheando o artigo, você encontrará nas páginas seguintes
um outro trecho de código cujo título não será \monoespaco{random.h},
mas sim ``Declarações de Gerador Aleatório''. Será ali que o código que
vai nesta parte do arquivo será encontrado. Pdem existir mais de um
trecho de código com este título. Isso significa que para produzir o
código funcional utilizado pelo compilador, devemos concatenar todos
estes trechos com o mesmo título e colocar na parte indicada deste
arquivo. Isso nos permite colocar a declaração de funções à medida que
formos explicando elas no código, sem precisar declarar todas de uma
vez só porque elas pertencem a um mesmo trecho de código.

\subsecao{1.4. Funções a serem Definidas}

Nosso gerador de números aleatórios deverá fornecer um total de 3
novas funções. A primeira delas irá criar a estrutura que contém o
gerador após receber a semente inicial (de 32 bits) e deve receber a
função que alocará o alocador (ou \monoespaco{NULL} para usar
o \monoespaco{malloc}):

\iniciocodigo
@<Declarações de Gerador Aleatório@>=
struct _Wrng *_Wcreate_rng(void *(*alloc)(size_t), uint32_t seed);
@
\fimcodigo

A segunda é a que efetivamente é usada para nos dar o próximo número
aleatório da sequência:

\iniciocodigo
@<Declarações de Gerador Aleatório@>+=
uint32_t _Wrand(struct _Wrng *);
@
\fimcodigo

A última função será apenas para finalizar o uso de um gerador de
números aleatórios. Ela recebe também um ponteiro para função que
desalocará o gerador (ou NULL). Ele não poderá mais ser usado depois
de finalizado:

\iniciocodigo
@<Declarações de Gerador Aleatório@>+=
bool _Wdestroy_rng(void (*free)(void *), struct _Wrng *);
@
\fimcodigo

\subsecao{1.5. Suporte à Threads}

O código adicionado aqui servirá para garantir que mais de uma thread
possa usar o gerador de números randômicos sem problemas após a sua
inicialização. Para isso precisamos de um cabeçalho adequado para
declarar os tipos que iremos usar:

\iniciocodigo
@<Incluir Cabeçalhos Necessários@>+=
#if defined(__unix__) || defined(__APPLE__)
#include <pthread.h>
#endif
#if defined(_WIN32)
#include <windows.h>
#endif
@
\fimcodigo

Tudo o que serápreciso fazer é, para cada gerador, definir um mutex a
ser colocado dentro do gerador (dentro do \monoespaco{struct \_Wrng}):

\iniciocodigo
@<Declaração de Mutex@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_t mutex;
#endif
#if defined(_WIN32)
CRITICAL_SECTION mutex;
#endif
@
\fimcodigo

Se temos um ponteiro para \monoespaco{struct \_Wrng} chamado
de \monoespaco{rng}, podemos inicializar seu mutex com:

\iniciocodigo
@<Inicialização de Mutex@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_init(&(rng -> mutex), NULL);
#endif
#if defined(_WIN32)
InitializeCriticalSection(&(rng -> mutex));
#endif
@
\fimcodigo

Para pedirmos o uso de um Mutex, fazemos:

\iniciocodigo
@<Mutex:WAIT@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_lock(&(rng -> mutex));
#endif
#if defined(_WIN32)
EnterCriticalSection(&(rng -> mutex));
#endif
@
\fimcodigo

E o código para liberarmos o uso do Mutex:

\iniciocodigo
@<Mutex:SIGNAL@>=
#if defined(__unix__) || defined(__APPLE__)
pthread_mutex_unlock(&(rng -> mutex));
#endif
#if defined(_WIN32)
LeaveCriticalSection(&(rng -> mutex));
#endif
@
\fimcodigo

Como desalocar o gerador de números aleatórios é deixado a cargo do
usuário, a única coisa que a função de finalizar o uso do gerador de
números aleatórios precisa fazer é finalizar seu Mutex. Podemos
definir o código dela inteiro aqui:

\iniciocodigo
@<Definição de \_Wdestroy\_rng@>=
bool _Wdestroy_rng(void (*free)(void *), struct _Wrng *rng){
  bool ret;
#if defined(__unix__) || defined(__APPLE__)
  ret = pthread_mutex_destroy(&(rng -> mutex));
#elif defined(_WIN32)
  DeleteCriticalSection(rng -> mutex);
  ret = true; // Sempre é bem-sucedida segundo a documentação
#endif
  if(free != NULL)
    free(rng);
  return ret;
}
@
\fimcodigo

\secao{2. Algoritmos Geradores de Números Pseudo-Randômicos}

\subsecao{2.1. SFMT}

O SFMT é o ``SIMD-Oriented Fast Mersenne Twister'', proposto pela
primeira vez em [Saito, 2006]. Ele tem esse nome porque o período
deste gerador é projetado para ter valores bastante grandes, que são
primos de Mersenne ($2^n-1$ para algum $n$ inteiro positivo). As
implementações mais usadas deste algoritmo suportam períodos de
$2^{19937}-1$ sem que haja repetição. O que é um exagero para qualquer
caso de uso, inclusive o uso em jogos eletrônicos. Já o ``SIMD'' é um
conjunto de instruções para valores de 128 bits que CPUs mais recentes
suportam. Tais instruções, se suportadas, são usadas para tornar o
desempenho mais rápido.

Como geradores de números randômicos são na prática tão rápidos, algo
que impacta muito na velocidade de sua geração é a necessidade de
invocar funções. Há duas formas de mitigar isso: gerar uma grande
quantidade de números em um buffer, que deve ser preenchido novamente
quando eles acabarem, ou pedir para o compilador tornar a
função \italico{inline\/}. Aqui não usaremos nenhuma das duas
otimizações. A primeira delas torna o tempo médio de execução muito
menor, mas aumenta o desvio padrão do tempo de execução, algo que
queremos evitar em programas interativos. A segunda não será usada por
não fazer diferença: a API que planejamos para o uso destas funções
deverá passar ponteiros para a função geradora de números aleatórios,
e ela tipicamente será executada por meio de tais ponteiros. Portanto,
o código tipicamente são seria expandido durante a compilação e uma
função seria invocada de qualquer forma.

O SFMT funciona por meio da seguinte recursão onde cada valor $X_i$ tem
$w$ bits:

$$
X_{i+n}=g(X_i, \ldots, X_{i+n-1})
$$

A função $g$ funciona concatenando toda a sua entrada na forma de um
vetor binário em $F_2$ com $wn$ elementos e multiplicando por
uma matriz $A\in F_2^{wn\times w}$. Na prática essa matriz é
escolhida de modo a ser simples e assim não precisar ser representada
ou armazenada. Ao invés disso ela simplesmente existirá na forma de
rotações de bits, operações AND e operações de XOR (os quais
correspondem à multiplicação e adição no corpo $F_2$).

Essa descrição genérica descreve toda a família de geradores Mersenne
Twister. Para o caso específico do SFMT, os valores que escolheremos
para nossas constantes será:

\iniciocodigo
@<Constantes RNG@>=
#ifdef W_RNG_MERSENNE_TWISTER
#define _W 128 // Tamanho de cada X_i gerado
#define _N 156 // Tamanho da recursão
#endif
@
\fimcodigo

Cada vez que geramos um novo número, temos que fazer a atualização
$w_0 \leftarrow w_1$, $w_1 \leftarrow w_2$ e assim por diante. Mas
podemos evitar ter que fazer tantas atribuições ou cópia mantendo
apenas uma variável com o índice de qual deverá ser o próximo elemento
a ser retornado pelo nosso gerador. por meio dele saberemos qual a
posição do próximo elemento de $(w_0, \ldots, w_{156})$ a ser
esquecido e substituído por um novo. Sendo assim, o formato de nossa
estrutura de RNG será:

\iniciocodigo
@<Estrutura RNG@>=
#ifdef W_RNG_MERSENNE_TWISTER
struct _Wrng{
  char w[_W * _N / 8]; // Todos N valores gerados, cada um com _W bits
  int offset;         // Index for the next 32-bit value to be returned
  @<Declaração de Mutex@>
};
#endif
@
\fimcodigo

O padrão ISO da linguagem C não suporta variáveis que garantidamente
tenham 128 bits. Contudo, versões recentes do compilador GCC e Clang
as suportam. Usando elas, podemos computar a função $g$ que computa o
próximo elemento da sequência (ou seja, a multiplicação de nosso vetor
por uma matriz em $F_2$) por meio da seguintes operações:

\iniciocodigo
@<SFMT: Computa próximo elemento@>=
#ifdef __SIZEOF_INT128__
unsigned __int128 result, tmp;
uint32_t aux[4];
int i, index = rng -> offset / 4;
result = ((unsigned __int128 *) (rng -> w))[index];
result = result << 8;
result = result ^ ((unsigned __int128 *) (rng -> w))[index];
i = (index + 122) % _N;
aux[0] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 0);
aux[1] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 1);
aux[2] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 2);
aux[3] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 3);
aux[0] = (aux[0] >> 11) & 0xDFFFFFEF; // 0xBFFFFFF6
aux[1] = (aux[1] >> 11) & 0xDDFECB7F; // 0xBFFAFFFF
aux[2] = (aux[2] >> 11) & 0xBFFAFFFF; // 0xDDFECB7F
aux[3] = (aux[3] >> 11) & 0xBFFFFFF6; // 0xDFFFFFEF
memcpy(&tmp, aux, 16);
result = result ^ tmp;
i = (index + _N - 2) % _N;
result = result ^ (((unsigned __int128 *) (rng -> w))[i] >> 8);
i = (index + _N - 1) % _N;
aux[0] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 0);
aux[1] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 1);
aux[2] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 2);
aux[3] = *(((uint32_t *) &(((unsigned __int128 *) (rng -> w))[i])) + 3);
aux[0] = (aux[0] << 18);
aux[1] = (aux[1] << 18);
aux[2] = (aux[2] << 18);
aux[3] = (aux[3] << 18);
memcpy(&tmp, aux, 16);
result = result ^ tmp;
((unsigned __int128 *) (rng -> w))[index] = result;
#else
#error "Mersenne Twister unsupported without 128 bit integer support." 
#endif
@
\fimcodigo

Essa geração de um próximo valor pseudo-randômico $w_i$ à partir de
$w_{i-1}$, $w_{i-2}$, $w_{i-N}$ e $w_{i-34}$ precisa ser então
integrada à função que efetivamente retorna o próximo número:

\iniciocodigo
@<Definição de \_Wrand@>=
#ifdef W_RNG_MERSENNE_TWISTER
uint32_t _Wrand(struct _Wrng *rng){
  uint32_t ret;
  @<Mutex:WAIT@>
  if(rng -> offset % 4 == 0){
    @<SFMT: Computa próximo elemento@>
  }
  ret = ((uint32_t *) (rng -> w))[rng -> offset];
  rng -> offset = (rng -> offset + 1) % (_W * _N / 32);
  @<Mutex:SIGNAL@>
  return ret;
}
#endif
@
\fimcodigo

Inicializar o nosso gerador é então uma questão de alocar espaço e
usar o seguinte método obtido da implementação de referência sobre
como inicializar o estado do gerador à partir da semente de 32 bits:

\iniciocodigo
@<Definição de \_Wcreate\_rng@>=
#ifdef W_RNG_MERSENNE_TWISTER
struct _Wrng *_Wcreate_rng(void *(*allocator)(size_t), uint32_t seed){
  int i;
  struct _Wrng *rng = (struct _Wrng *) allocator(sizeof(struct _Wrng));
  if(rng != NULL){
    uint32_t *p = (uint32_t *) (rng -> w);
    p[0] = seed;
    for(i = 1; i < _N * 4; i ++){
      p[i] = 1812433253UL * (p[i - 1] ^ (p[i - 1] >> 30)) + i;
    }
    rng -> offset = 0;
    @<SFMT: Garante Período@>
    @<Inicialização de Mutex@>
  }
  return rng;
}
#endif
@
\fimcodigo

Entretanto, antes de retornar o código acima é preciso checar se o
estado que geramos realmente tem o período desejado de
$2^{19937}-1$. O modo de fazer isso é por meio da checagem de paridade
para alguns bits específicos de nossa semente inicial. Se a paridade
nao estiver correta, apenas ajustamos ela sem precisar mudar os demais
valores gerados:

\iniciocodigo
@<SFMT: Garante Período@>=
{
  // Máscara de bits a serem checados:
  uint32_t parity = (p[0] & 0x00000001U) ^ (p[3] & 0xc98e126aU);
  // Checagem de paridade:
  for (i = 16; i > 0; i >>= 1)
    parity ^= parity >> i;
  parity = parity & 1;
  if(parity != 1)
    p[0] = p[0] ^ 1;
}
@
\fimcodigo

\subsecao{2.2. Xorshiro256**}

Este é um gerador mais recente que o SFMT e tem como objetivo manter a
mesma qualidade, fazê-lo passar em testes estatísticos adicionais, ser
rápido e não precisar de um estado tão grande assim. O Xorshiro é um
gerador linear, mas que combina sua operação linear com operações
não-lineares adicionais para que sua linearidade não o penalize em
testes estatísticos.

Basicamente ele precisa armazenar apenas os últimos 4 valores gerados
e realizar sobre eles a seguinte operação para gerar o próximo valor:

\iniciocodigo
@<Xorshiro: Computa próximo elemento@>=
{
  uint64_t tmp = rng -> w[1] * 5;
  rng -> result = ((tmp << 7) | (tmp >> 57)) * 9;
} 
@
\fimcodigo

O estado formado por apenas 4 números é atualizado após a geração de
cada elemento. Isso é feito como na definição de função abaixo:

\iniciocodigo
@<Definição de \_Wrand@>=
#ifdef W_RNG_XORSHIRO
uint32_t _Wrand(struct _Wrng *rng){
  uint32_t ret;
  @<Mutex:WAIT@>
  if(rng -> offset % 2 == 0){
    uint64_t t = rng -> w[1] << 17;
    @<Xorshiro: Computa próximo elemento@>
    // Atualiza estado:
    rng -> w[2] ^= rng -> w[0];
    rng -> w[3] ^= rng -> w[1];
    rng -> w[1] ^= rng -> w[2];
    rng -> w[0] ^= rng -> w[3];
    rng -> w[2] ^= t;
    rng -> w[3] = ((rng -> w[3] << 45) | (rng -> w[3] >> 19));
  }
  ret = (uint32_t) ((rng -> result) >> (32 * rng -> offset));
  rng -> offset = (rng -> offset + 1) % 2;
  @<Mutex:SIGNAL@>
  return ret;
}
#endif
@
\fimcodigo

A estrutura do gerador de números aleatórios Xorshiro então possui
apenas os últimos 4 valores de estado e o último valor de 64 bits a
ser retornado. Como nosso gerador só retorna números de 32 bits,
podemos aproveitar um mesmo valor gerado para retornar duas vezes:

\iniciocodigo
@<Estrutura RNG@>=
#ifdef W_RNG_XORSHIRO
struct _Wrng{
  uint64_t w[4];        // Valores de estado
  uint64_t result; // Last returned value
  int offset;      // If we have pending bits in result 
  @<Declaração de Mutex@>
};
#endif
@
\fimcodigo

Por fim, a inicialização do gerador Xorshiro** será:

\iniciocodigo
@<Definição de \_Wcreate\_rng@>=
#ifdef W_RNG_XORSHIRO
struct _Wrng *_Wcreate_rng(void *(*allocator)(size_t), uint32_t seed){
  int i;
  struct _Wrng *rng = (struct _Wrng *) allocator(sizeof(struct _Wrng));
  if(rng != NULL){
    uint32_t *p = (uint32_t *) (rng -> w);
    p[0] = seed;
    for(i = 1; i < 8; i ++)
      p[i] = 1812433253UL * (p[i - 1] ^ (p[i - 1] >> 30)) + i;
    rng -> offset = 0;
    rng -> result = 0;
    @<Inicialização de Mutex@>
  }
  return rng;
}
#endif
@
\fimcodigo

\subsecao{2.3. PCG (\italico{Permuted Congruential Generator})}

O terceiro gerador que será fornecido como opção é o PCG. Este gerador
usa ainda menos bits de estado que o Xorshiro:

\iniciocodigo
@<Estrutura RNG@>=
#ifdef W_RNG_PCG
struct _Wrng{
  uint64_t state;
  uint64_t increment; // Sempre deve ser ímpar
  @<Declaração de Mutex@>
};
#endif
@
\fimcodigo

Usamos para ele a mesma inicialização que para os outros geradores
dada uma semente de 32 bits. Mas temos que garantir que o valor de
incremento que usaremos será sempre ímpar:

\iniciocodigo
@<Definição de \_Wcreate\_rng@>=
#ifdef W_RNG_PCG
struct _Wrng *_Wcreate_rng(void *(*allocator)(size_t), uint32_t seed){
  struct _Wrng *rng = (struct _Wrng *) allocator(sizeof(struct _Wrng));
  if(rng != NULL){
    uint32_t *p = (uint32_t *) &(rng -> state);
    uint32_t *pinc = (uint32_t *) &(rng -> increment);
    p[0] = seed;
    p[1] = 1812433253UL * (p[0] ^ (p[0] >> 30)) + 1;
    pinc[0] = 1812433253UL * (p[1] ^ (p[1] >> 30)) + 2;
    pinc[1] = 1812433253UL * (pinc[0] ^ (pinc[0] >> 30)) + 3;
    rng -> increment = (rng -> increment | 1);
    @<Inicialização de Mutex@>
  }
  return rng;
}
#endif
@
\fimcodigo

E por fim, geramos um novo número aleatório por meio do seguinte código:

\iniciocodigo
@<Definição de \_Wrand@>=
#ifdef W_RNG_PCG
uint32_t _Wrand(struct _Wrng *rng){
  uint32_t ret, xorshifted, rot;
  @<Mutex:WAIT@>
  uint64_t oldstate = rng -> state;
  // Advance internal state
  rng -> state = oldstate * 6364136223846793005ULL + rng -> increment;
  xorshifted = ((oldstate >> 18u) ^ oldstate) >> 27u;
  rot = oldstate >> 59u;
  ret = (xorshifted >> rot) | (xorshifted << ((-rot) & 31));
  @<Mutex:SIGNAL@>
  return ret;
}
#endif
@
\fimcodigo

\subsecao{2.4. Gerador de Números Aleatórios do ISO C}

Ao invés do Mersenne Twister, Xorshiro e PCG, também há um suporte
para usar o próprio gerador de números aleatórios da biblioteca
padrão. Este recurso é oferecido para auxiliar em testes e
comparações, mas não é recomendado para uso em projetos. Um dos
motivos é o fato de ser um gerador reconhecidamente com menos
qualidade e pior dresempenho. Além disso, ele não irá necessariamente
funcionar de maneira correta quando usado por meio de threads.

Uma dificuldade inicial é que o gerador padrão não costuma retornar um
inteiro de 32 bits. Em alguns casos, o valor retornado pode ter apenas
15 bits (o maior número costuma ser o maior número do
tipo \monoespaco{int}). Na biblioteca C GNU, o número tem 31
bits. Sendo assim, para preencher bits restantes temos que invocar
mais de uma vez a função para obter mais bits. E vamos precisar de um
valor na nossa estrutura de gerador para armazenar quaisquer bits que
sobrarem para serem reaproveitados:

\iniciocodigo
@<Estrutura RNG@>=
#ifdef W_RNG_ISO_C
struct _Wrng{
  int accumulator;     // Some bits accumulated
  int remaining_bits;  // How many bits we have above
  int bits;            // How many bits rand() returns
  @<Declaração de Mutex@>
};
#endif
@
\fimcodigo

Ao criar este RNG, apenas armazenamos quantos bits a nossa função
padrão gera e inicializamos a estrutura como tendo 0 bits
acumulados. Além disso também inicializamos a função usando a semente
recebida:

\iniciocodigo
@<Definição de \_Wcreate\_rng@>=
#ifdef W_RNG_ISO_C
struct _Wrng *_Wcreate_rng(void *(*allocator)(size_t), uint32_t seed){
  struct _Wrng *rng = (struct _Wrng *) allocator(sizeof(struct _Wrng));
  if(rng != NULL){
    unsigned int max = ((unsigned int) RAND_MAX) + 1;
    rng -> accumulator = 0;
    rng -> remaining_bits = 0;
    rng -> bits = 0;
    while(max > 1){
      rng -> bits ++;
      max /= 2;
    }
    srand((unsigned int) seed);
    @<Inicialização de Mutex@>
  }
  return rng;
}
#endif
@
\fimcodigo

Para retornar um novo número pseudo-randômico, primeiro preenchemos os
bits menos significativos com os bits que temos acumulados. Em
seguida, com novos valores retornados pela função \monoespaco{rand},
nós vamos preenchendo valores mais e mais significativos. Se sobrar
alguns bits, armazenamos ele no estado de nosso gerador:

\iniciocodigo
@<Definição de \_Wrand@>=
#ifdef W_RNG_ISO_C
uint32_t _Wrand(struct _Wrng *rng){
  uint32_t ret;
  unsigned int filled_bits, new_value;
  @<Mutex:WAIT@>
  ret = rng -> accumulator;
  filled_bits = rng -> remaining_bits;
  while(filled_bits < 32){
    new_value = rand();
    ret += (new_value << filled_bits);
    filled_bits += rng -> bits;
  }
  rng -> remaining_bits = filled_bits - 32;
  rng -> accumulator = (new_value >> (rng -> bits - rng -> remaining_bits));
  @<Mutex:SIGNAL@>
  return ret;
}
#endif
@
\fimcodigo

\subsecao{2.5. Gerador Criptograficamente Seguro}

O código desta seção será fornecido para ser usado em testes e
comparações, mas seu uso não é recomendado para uso em outros
programas. Um dos motivos é o fato dele ignorar a semente que você
passa. os resultados obtidos com ele não podem ser repetidos passando
uma mesma semente. Além disso ele tem um desempenho reconhecidamente
pior que para aplicações não-criptográficas não compensa a
imprevisibilidade computacional. Por ser uma opção fornecida apenas
para fins de testes, este gerador é implementado meramente usando a
função \monoespaco{arc4random} de sistemas BSD.

A estrutura do RNG apenas armazena a sua semente (que nem é usada):

\iniciocodigo
@<Estrutura RNG@>=
#ifdef W_RNG_CRYPTO
struct _Wrng{
  uint32_t seed;
  @<Declaração de Mutex@>
};
#endif
@
\fimcodigo

Na criação do RNG armazenamos a semente ali apenas para evitarmos
avisos do compilador quanto a um parâmetro sendo ignorado pela função:

\iniciocodigo
@<Definição de \_Wcreate\_rng@>=
#ifdef W_RNG_CRYPTO
struct _Wrng *_Wcreate_rng(void *(*allocator)(size_t), uint32_t seed){
  struct _Wrng *rng = (struct _Wrng *) allocator(sizeof(struct _Wrng));
  if(rng != NULL){
    rng -> seed = seed;
    @<Inicialização de Mutex@>
  }
  return rng;
}
#endif
@
\fimcodigo

O uso do RNG consiste apenas na chamada da
função \monoespaco{arc4random} do sistema. Em sistemas operacionais
seguros ele é implementado por meio do gerador ChaCha20, embora ainda
possam existir sistemas que implementam ele com o algoritmo RC4, que não
é mais considerado criptograficamente seguro.

\iniciocodigo
@<Definição de \_Wrand@>=
#ifdef W_RNG_CRYPTO
uint32_t _Wrand(struct _Wrng *rng){
  return arc4random();
}
#endif
@
\fimcodigo


\subsecao{2.6. Estrutura Final do Arquivo}

O arquivo com o código-fonte de nossas funções terá a seguinte forma:


\iniciocodigo
@(src/random.c@>=
@<Incluir Cabeçalhos Necessários@>
#include "random.h"
#include <string.h> // memcpy
@<Definição de \_Wrand@>
@<Definição de \_Wcreate\_rng@>
@<Definição de \_Wdestroy\_rng@>
@
\fimcodigo

\secao{3. Testes de Qualidade}

Como forma de testar a qualidade de todos os algoritmos fornecidos e
fazer comparações, fazemos alguns testes estatísticos emíricos
sugeridos em [Knuth, 1998]. Uma ressalva é que muitos dos testes
sugeridos lá presume o desejo de gerar números aleatórios entre 0 e um
valor $n$, ou então valores reais entre 0 e 1. Contudo, se assumirmos
isso acabaremos dando um peso maior para os bits mais significativos
gerados. Não sabemos como o valor de 32 bits gerado pelas nossas
funções seria usado. Desta forma, queremos garantir a qualidade dele
em termos de cada um dos bits gerados. Desta forma, usamos os testes
sugeridos sempre que relevante, avaliando os valores de nosso gerados
como uma sequncia de bits e avaliamos como se isso fosse uma sequência
de zeros e uns gerados aleatoriamente.

Em todos os testes, aplicamos um teste como o Chi-Quadrado (ou
Smirnov-Kolmogorov) como sugerido na referência [Knuth,
1998]. Repetimos as medidas 3 vezes, se uma delas um valor aleatório
tiver uma chance inferior a 1\% de ser tão distante ou de ser tão
próximo do esperado, interrompemos os testes e consideramos uma
falha. Se por duas das três vezes testadas o valor obtido for algo com
apenas 5\% de chance de ser tão distante ou tão próximo do esperado,
também consideramos uma falha. Repetimos os três testes mil vezes e
geramos assim uma porcentagem de sucesso. Como referência, a menos que
seja dito o contrário, o valor esperado de sucesso é de 92,34\%.

\subsecao{3.1. Teste de Equidistribuição}

Basicamente neste teste geramos uma sequência de dez mil bits
aleatórios e avaliamos o quão bem distribuído o valor está entre zeros
e uns. Geramos a semente aleatória 2130833862 e obtivemos a seguinte
taxa de sucesso para nosos algoritmos:

\vbox{%A forma mais gseral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#&\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Gerador\hidewidth&&\omit\hidewidth
Sucesso\hidewidth&&
\omit\hidewidth Gerador\hidewidth&&Sucesso&\cr\linha
&&SFMT&&92\%&&Xorshiro**&&91\%&\cr\linha
&&PCG&&93\%&&\monoespaco{rand()}&&91\%&\cr\linha
&&ChaCha20&&93\%/94\%&&&&&\cr\linha}}


odos os algoritmos testados apresentaram desempenho satisfatório neste
teste mais básico. O valor inesperadamente alto do ChaCha2 aparenta
ser uma flutuação. Testando ele repetidas vezes, os valores obtidos
costumam ser muito mais próximos do esperado.

\subsecao{3.2. Teste Serial}

Este é o segundo teste empírico sugerido em [Knuth, 1998]. Nele,
escolhemos gerar 50000 pares de números entre 0 e 99 como sugerido por
Knuth na referência. Aplicamos sobre o resultado o teste
Chi-Quadrado. Assim como no teste anterior, repetimos o teste 3 vezes
e avaliando os 3 resultados como sucesso ou falha. E repetimos isso
mil vezes comparando o total de sucessos com o valor esperado (o valor
exato esperado é 92,34\%, mas medimos uma precisão de 1\%). Também
fizemos o teste primeiro sem inverter os bits dos valores gerados e
depois invertendo, gerando as duas porcentagens separadas por ``/''. O
resultado para a semente 125713416 gerada aleatoriamente foi:

\vbox{%A forma mais gseral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#&\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Gerador\hidewidth&&\omit\hidewidth
Sucesso\hidewidth&&
\omit\hidewidth Gerador\hidewidth&&Sucesso&\cr\linha
&&SFMT&&92\%/92\%&&Xorshiro**&&92\%/92\%&\cr\linha
&&PCG&&91\%/92\%&&\monoespaco{rand()}&&92\%/90\%&\cr\linha
&&ChaCha20&&93\%/91\%&&&&&\cr\linha}}

A importância deste teste é que enquanto o anterior garante que
eventualmente passaremos por todos os valores caso usemos o gerador
para gerar valores em um intervalo suficientemente restrito, este
garante que fazemos isso seguindo uma ordem que não é tão aparente
assim e que podemos usar o gerador também para gerar pares de valores.

Todos os algoritmos recomendados tiveram um desempenho igualmente bom
no teste e equivalente ao ideal. O único algoritmos que teve uma
qualidade ligeiramente inferior foi o gerador ISO (\monoespaco{rand})
quando invertemos a ordem dos bits. O ligeiro desempenho pior então
está nos bits menos significativos.

\subsecao{3.3. Teste de lacuna}

Este é o teste baseado no terceiro empírico sugerido em [Knuth,
1998]. Mas ao invés de fazer a medida de lacuna interpretando os
números obtidos como entre 0 e 1 como sugerido (o que daria novamente
um peso alto para os bits mais significativos), nós medimos a lacuna
de bits: interpretamos os valores retornados pelo gerados como uma
sequência contínua de bits. E contamos o tamanho das lacunas
encontradas (sequências de bits 0 terminadas em bits 1).

Por exemplo, na sequência ``100110010100001'' obtemos as lacunas ``1''
(tamanho 0), ``001'' (tamanho 2), ``1'' (tamanho 0), ``001'' (tamanho
2), ``01'' (tamanho 1) e ``00001'' (tamanho 4). Em cada gerador
obtemos uma amostragem de $5\cdot2^{20}$ lacunas e avaliamos a
quantidade de cada tamanho de lacunas com um teste de
chi-quadrado. Aplicamos então a mesma avaliação dos outros testes e
medimos a taxa de sucesso (novamente esperada como sendo próxima de
92,34\%). O resultado obtido para a semente 3558029206 gerada
aleatoriamente foi:

\vbox{%A forma mais gseral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#&\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Gerador\hidewidth&&\omit\hidewidth
Sucesso\hidewidth&&
\omit\hidewidth Gerador\hidewidth&&Sucesso&\cr\linha
&&SFMT&&91\%&&Xorshiro**&&90\%&\cr\linha
&&PCG&&93\%&&\monoespaco{rand()}&&91\%&\cr\linha
&&ChaCha20&&91\%&&&&&\cr\linha}}

Novamente os testes ficaram próximos do valor esperado para todos os
algoritmos, apenas com o Xorshro** tendo uma taxa muito ligeiramente
menor de sucesso.

\secao{3. Medida de Desempenho}

Após medir o desempenho dos algoritmos implementados, o seguinte
resultado foi obtido (as colunas mostram o tempo de geração de cada
número e o desvio padrão em nanossegundos e o tamanho da esrutura que
armazena o gerador):

\vbox{%A forma mais gseral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#&\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Gerador\hidewidth&&\omit\hidewidth
Tempo ($\mu$s)\hidewidth&&
\omit\hidewidth Desvio ($\mu$s)\hidewidth&&Tamanho (bytes)&\cr\linha
&&SFMT&&783&&124&&2544&\cr\linha
&&Xorshiro**&&786&&127&&88&\cr\linha
&&PCG&&786&&149&&56&\cr\linha}}

O teste foi feito em um computador com processador Intel Pentium B980
dual core com 2,40 GHz e 4 GB de memória RAM. O Sistema Operacional
foi o Ubuntu 18.04.4. O teste foi compilado com o GCC 7.5.0.

\secao{4. Conclusão}

Apesar de gastar muito mais memória que as outras implementações, a
versão utilizada do Mersenne Twister (o SFMT) ainda é muito mais
rápida que o dos algoritmos mais recentes utilizados, mesmo que não
utilizemos algumas otimizações comuns (tornar a função ``inline'' ou
gerar antecipadamente muitos valores em um buffer). Isso possivelmente
se deve às suas operações feitas para serem rápidas em processadores
com registradores e operações de 128 bits. Contudo, é importante notar
que nós só implementamos uma versão do Mersenne Twister que usa tais
recursos e também usa uma extensão da linguagem C com variáveis de 128
bits. Caso estas opções não estejam disponíveis, temos que recorrer a
outro algoritmo.

Por causa disso, e como não há uma grande diferença de qualidade entre
os algoritmos, em nossa biblioteca usaremos o SFMT se possível, e se
não for possível, usemos o PCG por se mostrar ligeiramente mais rápido
e menor que o Xorshiro:

\iniciocodigo
@<Escolhe Algoritmo Padrão do RNG@>=
#if !defined(W_RNG_MERSENNE_TWISTER) && !defined(W_RNG_XORSHIRO) && \
!defined(W_RNG_PCG) && !defined(W_RNG_ISO_C) && !defined(W_RNG_CRYPTO)
#ifdef __SIZEOF_INT128__
#define W_RNG_MERSENNE_TWISTER
#else
#define W_RNG_PCG
#endif
#endif
@
\fimcodigo

\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer Journal,
volume 27, edição 2, p. 97--111}

\referencia{Knuth, D. (1998) ``The Art of Computer Programming, v. 2:
Seminumerical Algorithms'', Addison-Wesley Professional, terceira
edição.}

\referencia{Saito, M.; Matsumoto M. (2006) ``SIMD-oriented fast Mersenne Twister: a 128-bit pseudorandom number generator'', Monte Carlo and Quasi-Monte Carlo Methods, Springer, p. 607--622}.

\fim
